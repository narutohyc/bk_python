<img src="http://upload-images.jianshu.io/upload_images/15675864-952291e89189c8a8.jpg">



记录python学习中遇到的一些心得：

[TOC]

***


# Python的collections模块

> 1. [collections — Container datatypes](https://docs.python.org/3.7/library/collections.html)
> 	 namedtuple(): 生成可以使用名字来访问元素内容的tuple子类
>     deque: 双端队列，可以快速的从另外一侧追加和推出对象
>     Counter: 计数器，主要用来计数
>     OrderedDict: 有序字典
>     defaultdict: 带有默认值的字典
>    	 ChainMap	类似字典(dict)的容器类，将多个映射集合到一个视图里面
>    	 UserDict	封装了字典对象，简化了字典子类化
>    	 UserList	封装了列表对象，简化了列表子类化
>    	 UserString	封装了列表对象，简化了字符串子类化
>     collections.abc  抽象基类

> tuple的几个特性：
> 1. 不可变，iterable
> 2. 拆包
> 3. tuple不可变不是绝对的
> 4. tuple比list好的地方
>     4.1 immutable的重要性：性能优化(元素全为immutable的会作为常量在编译时确定)、线程安全、可以作为dict的key，拆包特性
>     4.2 tuple类似struct，list类似array

# namedtuple： 使用名字访问元素

```python
# namedtuple： 生成可以使用名字来访问元素内容的tuple子类
# -*- coding: utf-8 -*
from collections import namedtuple

User = namedtuple("USER", ["name", "age", "city", "height"])
user_1 = User(name="雷鸣", age=21, city="北京", height="175")
print("user_1", user_1.name, user_1.age, user_1.city, user_1.height)

user_tuple = ("雷姆", 17, '异世界')
user_2 = User(*user_tuple, "172")
print("user_2", user_2.name, user_2.age, user_2.city, user_2.height)

user_dict = {
    "name": "雷玖",
    "age": "17",
    "city": "异世界",
}
user_3 = User(**user_dict, height="172")
print("user_3", user_3.name, user_3.age, user_3.city, user_3.height)

user_tuple_2 = ("雷姆", 17, '异世界', "172")
user_list_2 = ["雷姆", 17, '异世界', "172"]
user_dict_2 = {
    "name": "雷玖",
    "age": "17",
    "city": "异世界",
    "height": "172"
}
user_4 = User._make(user_dict_2)
print("user_4", user_4.name, user_4.age, user_4.city, user_4.height)
user_5 = User._make(user_tuple_2)
print("user_5", user_5.name, user_5.age, user_5.city, user_5.height)
user_6 = User._make(user_list_2)
print("user_6", user_6.name, user_6.age, user_6.city, user_6.height)

print(user_2._asdict())


user_1 雷鸣 21 北京 175
user_2 雷姆 17 异世界 172
user_3 雷玖 17 异世界 172
user_4 name age city height
user_5 雷姆 17 异世界 172
user_6 雷姆 17 异世界 172
OrderedDict([('name', '雷姆'), ('age', 17), ('city', '异世界'), ('height', '172')])

item = ('a','b','a','a',5)

for it in set(item):
    print(f'{it} 出现了{item.count(it)}次')
b 出现了1次
5 出现了1次
a 出现了3次
```

# defaultdict带默认值

```python
# defaultdict: 带有默认值的字典
# 错误方式
>>> student_grades = {}
>>> grades = [
...     ('elliot', 91),
...     ('neelam', 98),
...     ('bianca', 81),
...     ('elliot', 88),
... ]
>>> for name, grade in grades:
...     if name not in student_grades:
...         student_grades[name] = []
...     student_grades[name].append(grade)
...
>>> student_grades
{'elliot': [91, 88], 'neelam': [98], 'bianca': [81]}
>>> for name, grade in grades:
...     student_grades.setdefault(name,[])
...     student_grades[name].append(grade)
...
>>> student_grades
{'elliot': [91, 88], 'neelam': [98], 'bianca': [81]}

# 正确方式
>>> from collections import defaultdict
>>> student_grades = defaultdict(list)
>>> for name, grade in grades:
...     student_grades[name].append(grade)

# 在这种情况下，你将创建一个defaultdict，它使用不带参数的list构造函数作为默认方法。没有参数的list返回一个空列表，因此如果名称不存在则defaultdict调用list()，然后再把学生成绩添加上。如果你想更炫一点，你也可以使用lambda函数作为值来返回任意常量。
```

# 7.3 deque高效队列

```python
# deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：
# 使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。
>>> from collections import deque
>>> q = deque(['a', 'b', 'c'])
>>> q.append('x')
>>> q.appendleft('y')
>>> q
deque(['y', 'a', 'b', 'c', 'x'])

# deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素
# deque是线程安全的，有GIL保护

# 其他特性
    clear(清空队列)
    copy(浅拷贝)
    count(返回指定元素的出现次数)
    extendleft(从队列左边扩展一个列表的元素)
    index（查找某个元素的索引位置）
    extend(从队列右边扩展一个列表的元素)
    insert（在指定位置插入元素）
    pop（获取最右边一个元素，并在队列中删除）
    popleft（获取最左边一个元素，并在队列中删除）
    remove（删除指定元素）
    reverse（队列反转）
    rotate（把右边元素放到左边）
```

# Counter统计

```python
# Counter统计
# -*- coding: utf-8 -*
from collections import Counter

users = ["yellow", "red", "red", "yellow", "yellow"]
user_counter = Counter(users)
print(user_counter)
print(user_counter.most_common(2))

word_counter = Counter("abcdabd")
# 叠加统计
word_counter.update(Counter("efeg"))
word_counter.update("141")
print(word_counter)


Counter({'yellow': 3, 'red': 2})
[('yellow', 3), ('red', 2)]
Counter({'a': 2, 'b': 2, 'd': 2, 'e': 2, '1': 2, 'c': 1, 'f': 1, 'g': 1, '4': 1})
```

# OrderedDict

```python
# 使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。

# 如果要保持Key的顺序，可以用OrderedDict
# OrderedDict的Key会按照插入的顺序排列，不是Key本身排序
# 例子1
from collections import OrderedDict
d = {'banana': 3, 'apple': 4}
od1 = OrderedDict({'banana': 3, 'apple': 4})
od2 = OrderedDict({'apple': 4, 'banana': 3})
print(od1 == od2)
print(od1 == d)

False
True

# 例子2
from collections import OrderedDict
od1 = OrderedDict({'banana': 3, 'apple': 4})
od1.popitem(False)
print(od1)
od1.pop('banana') # 这里必须提供key

OrderedDict([('apple', 4)])


# 例子3
from collections import OrderedDict
od1 = OrderedDict({'banana': 3, 'apple': 4})
od1.move_to_end('banana')
print(od1)

OrderedDict([('apple', 4), ('banana', 3)])


# 例子4
# OrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key
from collections import OrderedDict
class LastUpdatedOrderedDict(OrderedDict):
    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity

    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey >= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)
```

# ChainMap

```python
# ChainMap 类是为了将多个映射快速的链接到一起，这样它们就可以作为一个单元处理。它通常比创建一个新字典和多次调用 update() 要快很多

from collections import ChainMap
a = {'a': 1, 'b': 2}
b = {'c': 3}
c = ChainMap(a, b) # 如果有重复的key，以第一次为准
print(c)
# 将数据以列表形式展现，实际上是将链接指向原来的实现
print(c.maps)
print(c.maps[0]['b'])

ChainMap({'a': 1, 'b': 2}, {'c': 3})
[{'a': 1, 'b': 2}, {'c': 3}]
2

# 简单应用
一个Python命令中，如果在命令行中输入参数则使用该参数，没有则从OS环境变量中获取，如果还没有再取自定义默认值
import os
import argparse
from collections import ChainMap
defaults = {'color': 'red', 'user': 'guest'}
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = {k: v for k, v in vars(namespace).items() if v}
combined = ChainMap(command_line_args, os.environ, defaults)
print(combined['color'])
print(combined['user'])

red
guest
```


