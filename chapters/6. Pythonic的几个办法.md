<img src="http://upload-images.jianshu.io/upload_images/15675864-952291e89189c8a8.jpg">



记录python学习中遇到的一些心得：

[TOC]

***

# Pythonic的几个办法

> 1. [Python难点解析---高级篇2.Pythonic](https://www.jianshu.com/p/5a7dfaa35abc)

# enumerate迭代

```python
>>> numbers = [45, 22, 14, 65, 97, 72]
>>> for i, num in enumerate(numbers):
...     if num % 3 == 0 and num % 5 == 0:
...         numbers[i] = 'fizzbuzz'
...     elif num % 3 == 0:
...         numbers[i] = 'fizz'
...     elif num % 5 == 0:
...         numbers[i] = 'buzz'
...
>>> numbers
['fizzbuzz', 22, 14, 'buzz', 97, 'fizz']
# 对于每个元素，enumerate()返回一个计数器和元素值。计数器默认为0，也是元素的索引。不想在0开始你的计数？只需使用可选的start参数来设置偏移量

>>> numbers = [45, 22, 14, 65, 97, 72]
>>> for i, num in enumerate(numbers, start=52):
...     print(i, num)
...
52 45
53 22
54 14
55 65
56 97
57 72
```

# 递推式构造列表

```python
>>> numbers = [4, 2, 1, 6, 9, 7]
>>> def square(x):
...     return x*x
...
>>> list(map(square, numbers))
[16, 4, 1, 36, 81, 49]

>>> [square(x) for x in numbers]
[16, 4, 1, 36, 81, 49]
# 使用map()和列表推导的两种方法都返回相同的值，但列表推导更容易阅读和理解。

>>> def is_odd(x):
...    return bool(x % 2)
...
>>> list(filter(is_odd, numbers))
[1, 9, 7]

>>> [x for x in numbers if is_odd(x)]
[1, 9, 7]
# ，filter和列表推导方法返回相同的值，但列表推导更容易理解。
```

# 代码调试技巧

```python
# Python 代码调试技巧
https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/index.html

# 如果你使用的是Python 3.7，则无需导入任何内容，只需在代码中要放入调试器的位置调用breakpoint()：
# Some complicated code with bugs

breakpoint()
# 调用breakpoint()会将你带入pdb，这是默认的Python调试器。在Python 3.6及更早版本中，你可以通过显式导入pdb来执行相同的操作：
import pdb; 
pdb.set_trace()

# 像breakpoint()一样，pdb.set_trace()会将你带入pdb调试器。它不是那么简洁，而且需要记住的多一点。你可能想要尝试其他调试器，但pdb是标准库的一部分，因此它始终可用。无论你喜欢哪种调试器，在进行编码面试设置之前，都值得尝试使用它们来适应工作流程。
```

# 使用f-Strings格式化字符串

```python
# f-strings支持使用字符串格式化迷你语言，以及强大的字符串插值。这些功能允许你添加变量甚至有效的Python表达式，并在添加到字符串之前在运行时对它们进行评估：
>>> def get_name_and_decades(name, age):
...     return f"My name is {name} and I'm {age / 10:.5f} decades old."
...
>>> get_name_and_decades("Maria", 31)
My name is Maria and I'm 3.10000 decades old.
```

# 列表排序

Python中拥有内置函数实现排序，可以直接调用它们实现排序功能

Python 列表有一个内置的 `list.sort()` 方法可以直接修改列表。还有一个 `sorted()` 内置函数，它会从一个可迭代对象构建一个新的排序列表。

> list.sort(cmp=None, key=None, reverse=False)
>
> 其中参数的含义是：
>
> * **cmp** -- 可选参数, 如果指定了该参数会使用该参数的方法进行排序。
>
> * **key** -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
>
> * **reverse** -- 排序规则，reverse = True 降序， reverse = False 升序（默认）。

> sorted(iterable, cmp=None, key=None, reverse=False)
>
> * **erable** -- 可迭代对象。
>
> * **cmp** -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
>
> * **key** -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
>
> * **reverse** -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。
>
> ```python
> # 默认情况下，sorted()已按升序对输入进行排序，而reverse关键字参数则按降序排序。
> >>> sorted(['cat', 'dog', 'cheetah', 'rhino', 'bear'], reverse=True)
> ['rhino', 'dog', 'cheetah', 'cat', 'bear]
> 
> >>> animals = [
> ...     {'type': 'penguin', 'name': 'Stephanie', 'age': 8},
> ...     {'type': 'elephant', 'name': 'Devon', 'age': 3},
> ...     {'type': 'puma', 'name': 'Moe', 'age': 5},
> ... ]
> >>> sorted(animals, key=lambda animal: animal['age'])
> [
>     {'type': 'elephant', 'name': 'Devon', 'age': 3},
>     {'type': 'puma', 'name': 'Moe', 'age': 5},
>     {'type': 'penguin', 'name': 'Stephanie, 'age': 8},
> ]
> # 通过传入一个返回每个元素年龄的lambda函数，可以轻松地按每个字典的单个值对字典列表进行排序。在这种情况下，字典现在按年龄按升序排序。
> ```
>
> 

> **sort ()与sorted()区别：**

sort() 是应用在 list 上的方法，sorted() 可以对所有可迭代的对象进行排序操作。

list 的 sort() 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted() 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。

# set存储唯一值

```python
>>> import random
>>> all_words = "all the words in the world".split()
>>> def get_random_word():
...    return random.choice(all_words)
>>> def get_unique_words():
...     words = set()
...     for _ in range(1000):
...         words.add(get_random_word())
...     return words
>>> get_unique_words()
{'world', 'all', 'the', 'words'}
```

# 节省内存的生成器

```python
# 前面提到，列表推导是方便的工具，但有时会导致不必要的内存使用。
# 错误方式
>>> sum([i * i for i in range(1, 1001)])
333833500
# 正确方式
>>> sum((i * i for i in range(1, 1001)))
333833500
# 换出括号会将列表推导更改为生成器表达式。当你知道要从序列中检索数据，但不需要同时访问所有数据的时候，生成器表达式非常适合。 

# 生成器表达式返回生成器对象，而不是创建列表。该对象知道它在当前状态中的位置（例如，i = 49）并且仅在被要求时计算下一个值。 

# 因此，当sum通过重复调用.__ next __()来迭代生成器对象时，生成器检查i等于多少，计算i * i，在内部递增i，并将正确的值返回到sum。该设计允许生成器用于大量数据序列，因为一次只有一个元素存在于内存中。
```

# 字典定义默认值

```python
# 错误方式
>>> cowboy = {'age': 32, 'horse': 'mustang', 'hat_size': 'large'}
>>> if 'name' in cowboy:
...     name = cowboy['name']
... else:
...     name = 'The Man with No Name'
...
>>> name
'The Man with No Name'
# 正确方式
>>> name = cowboy.get('name', 'The Man with No Name')
# get()执行与第一种方法相同的操作，但现在它们会自动处理。如果key存在，则返回适当的值。否则，将返回默认值

# 如果你想在仍然访问name的key时使用默认值更新字典
# 错误方式
>>> if 'name' not in cowboy:
...     cowboy['name'] = 'The Man with No Name'
...
>>> name = cowboy['name']
# 正确方式
>>> name = cowboy.setdefault('name', 'The Man with No Name')
```

# defaultdict()处理缺少的字典键

详见: <a href="#12.2 defaultdict带有默认值的字典">12.2 defaultdict带有默认值的字典</a>

# Counter计算Hashable对象

```python
# 假如你有一长串没有标点符号或大写字母的单词，你想要计算每个单词出现的次数。
# 你可以使用字典或defaultdict增加计数，但collections.Counter提供了一种更清晰，更方便的方法。 Counter是dict的子类，它使用0作为任何缺失元素的默认值，并且更容易计算对象的出现次数：
>>> from collections import Counter
>>> words = "if there was there was but if there was not there was not".split()
# 或者  counts = Counter(if=2,there=4,was=4,not=2,but=1) # 传进元组
>>> counts = Counter(words)
>>> counts
Counter({'if': 2, 'there': 4, 'was': 4, 'not': 2, 'but': 1})

# 当你将单词列表传递给Counter时，它会存储每个单词以及该单词在列表中出现的次数。
# 如果你好奇两个最常见的词是什么？只需使用.most_common（）：
print(counts.most_common(2))
[('there', 4), ('was', 4)]

# 遍历所有元素
>>> for k,v in counts.items():
... 	print(k,v)
if 2
there 4
was 4
but 1
not 2

#遍历打印所有元素
print(sorted(counts.elements()))
['but', 'if', 'if', 'not', 'not', 'there', 'there', 'there', 'there', 'was', 'was', 'was', 'was']

# update(增加元素)
counts.update("if you are here".split())
print(counts)
Counter({'there': 4, 'was': 4, 'if': 3, 'not': 2, 'but': 1, 'you': 1, 'are': 1, 'here': 1})

# subtract(原来的元素减去新传入的元素)
counts.subtract(['if']) # if的次数减一
print(counts)
Counter({'there': 4, 'was': 4, 'if': 2, 'not': 2, 'but': 1, 'you': 1, 'are': 1, 'here': 1})

# 删除元素
counts['but'] = 0
del counts['but']

c = Counter(a=3, b=1)
d = Counter(a=1, b=2)
c + d                       # 相加
#Counter({'a': 4, 'b': 3})
c - d                       # 相减，如果小于等于0，删去
#Counter({'a': 2})
c & d                       # 求最小
#Counter({'a': 1, 'b': 1})
c | d                       # 求最大
#Counter({'a': 3, 'b': 2})
```

# 使用字符串常量访问公共字符串组

```python
# 可以使用is_upper()，它返回字符串中的所有字符是否都是大写字母：
>>> import string
>>> def is_upper(word):
...     for letter in word:
...         if letter not in string.ascii_uppercase:
...             return False
...     return True
...
>>> is_upper('Thanks Geir')
False
>>> is_upper('LOL')
True

# is_upper()迭代word中的字母，并检查字母是否为string.ascii_大写字母的一部分。如果你打印出string.ascii_大写，你会发现它只是一个字符串，该值设置为文本“ABCDEFGHIJKLMNOPQRSTUVWXYZ”。

所有字符串常量都只是经常引用的字符串值的字符串。其中包括以下内容：
string.ascii_letters
string.ascii_uppercase
string.ascii_lowercase
string.digits
string.hexdigits
string.octdigits
string.punctuation
string.printable
string.whitespace
```

# 使用Itertools生成排列和组合

```python
# itertools.permutations()构建所有排列的列表，这意味着它是输入值的每个可能分组的列表，其长度与count参数匹配。r关键字参数允许我们指定每个分组中有多少值：
>>> import itertools
>>> friends = ['Monique', 'Ashish', 'Devon', 'Bernie']
>>> list(itertools.permutations(friends, r=2))
[('Monique', 'Ashish'), ('Monique', 'Devon'), ('Monique', 'Bernie'),
('Ashish', 'Monique'), ('Ashish', 'Devon'), ('Ashish', 'Bernie'),
('Devon', 'Monique'), ('Devon', 'Ashish'), ('Devon', 'Bernie'),
('Bernie', 'Monique'), ('Bernie', 'Ashish'), ('Bernie', 'Devon')]

# itertools.combinations()生成组合。这些也是输入值的可能分组，但现在值的顺序无关紧要。
>>> list(itertools.combinations(friends, r=2))
[('Monique', 'Ashish'), ('Monique', 'Devon'), ('Monique', 'Bernie'),
('Ashish', 'Devon'), ('Ashish', 'Bernie'), ('Devon', 'Bernie')]
```

# 漂亮的打印出JSON

```python
>>> import json
>>> print(json.dumps(data))  # No indention
{"status": "OK", "count": 2, "results": [{"age": 27, "name": "Oz", "lactose_intolerant": true}, {"age": 29, "name": "Joe", "lactose_intolerant": false}]}
>>> print(json.dumps(data, indent=2))  # With indention
{
  "status": "OK",
  "count": 2,
  "results": [
    {
      "age": 27,
      "name": "Oz",
      "lactose_intolerant": true
    },
    {
      "age": 29,

      "name": "Joe",
      "lactose_intolerant": false
    }
  ]
}
```

# 上下文管理(with ** as ** )

```python
with allocate_resource() as resource:
    resource.use()

# 打开/关闭文件
with open('data.txt') as f:
    data = f.read()
```

# 合理使用列表

```python
from collections import deque
names = deque(['raymond', 'rachel', 'matthew', 'roger',
               'betty', 'melissa', 'judith', 'charlie'])
names.popleft()
               
Out[10]: 'raymond'
```

1. 列表对象（list）是一个查询效率高于更新操作的数据结构，删除和插入需要对剩下的元素做移动操作
2. deque 是一个双向队列的数据结构，删除元素和插入元素会很快

# 序列解包

```python
p = 'vttalk', 'female', 30, 'python@qq.com'
name, gender, age, email = p
name, gender, age, email
Out[13]: ('vttalk', 'female', 30, 'python@qq.com')
    
num_list = [100, 19, 20, 98]
first, *left_num_list, last = num_list
print(first, left_num_list, last)
Out[14]: 100 [19, 20] 98
```

# 遍历字典的 key 和 value

```python
# Non-Pythonic
# 方法一
for k in d:
    print k, '--->', d[k]
# 方法二
for k, v in d.items():
    print k, '--->', v
    
# Pythonic
for k, v in d.iteritems():
    print k, '--->', v
```

# 链式比较操作

```python
if 18 < age < 60:
    print("yong man")
```

# for/else语句

```python
# for else 是 Python 中特有的语法格式，else 中的代码在 for 循环遍历完所有元素之后执行
# 如果for循环正常结束，else中语句执行。如果是break的，则不执行。
for i in mylist:
    if i == theflag:
		break
    process(i)
else:
    raise ValueError("List argument missing terminal flag.")
```

```python
# 方式一
flag = False
for x in xx:
	if some condition:
		flag = True
		break
if flag:
	print 'no break'
```

```python
# 方式二
for x in xx:
	if some condition:
		break
else:
	print 'no break'
```

```python
# 判断质数/素数——我知道的最快的方法
# https://blog.csdn.net/songyunli1111/article/details/78690447
# Example
def is_prime(n = 20):
    is_p = False
    for ii in range(2 if n>=2 else 1, int(math.sqrt(n))+1):
        if n%ii == 0:
            break
    else:
        is_p = True
    return is_p
```

# 运行时间装饰器

```python
# 作为装饰器使用，返回函数执行需要花费的时间
def time_this_function(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'{func.__name__}, 耗时{round(end - start, 4)}s')
        return result
    return wrapper
```

# assert用法

```python
>>> assert mul(2, 3) == 7, 'This statement is wrong!!!!!!'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError: This statement is wrong!!!!!!
```

# slots优化内存

> 使用__slots__使用了100M内存，比使用__dict__存储属性值节省了2倍。
> 其实使用collection模块的namedtuple也可以实现__slots__相同的功能。namedtuple其实就是继承自tuple，同时也因为__slots__的值被设置成了一个空tuple以避免创建__dict__
> collection 和普通创建类方式相比，也节省了不少的内存。所在在确定类的属性值固定的情况下，可以使用__slots__方式对内存进行优化。但是这项技术不应该被滥用于静态类或者其他类似场合，那不是python程序的精神所在。

```python
# 未使用__slots__
# -*- coding: utf-8 -*
from memory_profiler import profile
class Foobar(object):
    # __slots__ = ('x')
    def __init__(self, x):
        self.x = x
@profile
def main():
    f = [Foobar(42) for i in range(1000000)]
if __name__ == "__main__":
    main()

    
Line #    Mem usage    Increment   Line Contents
================================================
   137     45.7 MiB     45.7 MiB   @profile
   138                             def main():
   139    215.9 MiB      0.9 MiB       f = [Foobar(42) for i in range(1000000)]
```

```python
# 使用__slots__
# -*- coding: utf-8 -*
from memory_profiler import profile
class Foobar(object):
    __slots__ = ('x')
    def __init__(self, x):
        self.x = x
@profile
def main():
    f = [Foobar(42) for i in range(1000000)]

if __name__ == "__main__":
    main()

Line #    Mem usage    Increment   Line Contents
================================================
   132     45.7 MiB     45.7 MiB   @profile
   133                             def main():
   134     99.8 MiB      0.4 MiB       f = [Foobar(42) for i in range(1000000)]
```

```python
# 使用__slots__要注意，__slots__定义的属性仅对当前类起作用，对继承的子类是不起作用的
# 除非在子类中也定义__slots__，这样，子类允许定义的属性就是自身的__slots__加上父类的__slots__。
```

# 暂留
