<img src="http://upload-images.jianshu.io/upload_images/15675864-952291e89189c8a8.jpg">



记录python学习中遇到的一些心得：

[TOC]

***

# Pythonic的几个办法

> 1. [Python难点解析---高级篇2.Pythonic](https://www.jianshu.com/p/5a7dfaa35abc)

# enumerate迭代

```python
>>> numbers = [45, 22, 14, 65, 97, 72]
>>> for i, num in enumerate(numbers):
...     if num % 3 == 0 and num % 5 == 0:
...         numbers[i] = 'fizzbuzz'
...     elif num % 3 == 0:
...         numbers[i] = 'fizz'
...     elif num % 5 == 0:
...         numbers[i] = 'buzz'
...
>>> numbers
['fizzbuzz', 22, 14, 'buzz', 97, 'fizz']
# 对于每个元素，enumerate()返回一个计数器和元素值。计数器默认为0，也是元素的索引。不想在0开始你的计数？只需使用可选的start参数来设置偏移量

>>> numbers = [45, 22, 14, 65, 97, 72]
>>> for i, num in enumerate(numbers, start=52):
...     print(i, num)
...
52 45
53 22
54 14
55 65
56 97
57 72
```

# 列表递推式

> 列表推导是构建列表（`list`）的快捷方式，而生成器表达式则可以用来创建其他任何类型的序列。
>
> 通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短。如果列表推导的代码超过了两行，你可能就要考虑是不是得用 `for` 循环重写了。
>
> 在 Python 3 中都有了自己的局部作用域，就像函数似的。表达式内部的变量和赋值只在局部起作用，表达式的上下文里的同名变量还可以被正常引用，局部变量并不会影响到它们。
>
> 列表推导可以帮助我们把一个序列或是其他可迭代类型中的元素过滤或是加工，然后再新建一个列表。
>
> 列表推导的作用只有一个：生成列表。如果想生成其他类型的序列，生成器表达式就派上了用场。
>
> 

```python
>>> numbers = [4, 2, 1, 6, 9, 7]
>>> def square(x):
...     return x*x
...
>>> list(map(square, numbers))
[16, 4, 1, 36, 81, 49]

>>> [square(x) for x in numbers]
[16, 4, 1, 36, 81, 49]
# 使用map()和列表推导的两种方法都返回相同的值，但列表推导更容易阅读和理解。

>>> def is_odd(x):
...    return bool(x % 2)
...
>>> list(filter(is_odd, numbers))
[1, 9, 7]

>>> [x for x in numbers if is_odd(x)]
[1, 9, 7]
# ，filter和列表推导方法返回相同的值，但列表推导更容易理解。
```

# 生成器表达式

> 生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。
>
> 生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已。
>
> 如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它围起来。
>
> 生成器表达式就可以帮忙省掉运行 `for` 循环的开销

```python
# 前面提到，列表推导是方便的工具，但有时会导致不必要的内存使用。
# 错误方式
>>> sum([i * i for i in range(1, 1001)])
333833500
# 正确方式
>>> sum((i * i for i in range(1, 1001)))
333833500
# 换出括号会将列表推导更改为生成器表达式。当你知道要从序列中检索数据，但不需要同时访问所有数据的时候，生成器表达式非常适合。 

# 生成器表达式返回生成器对象，而不是创建列表。该对象知道它在当前状态中的位置（例如，i = 49）并且仅在被要求时计算下一个值。 

# 因此，当sum通过重复调用.__ next __()来迭代生成器对象时，生成器检查i等于多少，计算i * i，在内部递增i，并将正确的值返回到sum。该设计允许生成器用于大量数据序列，因为一次只有一个元素存在于内存中。
```

# 使用f-Strings格式化字符串

```python
# f-strings支持使用字符串格式化迷你语言，以及强大的字符串插值。这些功能允许你添加变量甚至有效的Python表达式，并在添加到字符串之前在运行时对它们进行评估：
>>> def get_name_and_decades(name, age):
...     return f"My name is {name} and I'm {age / 10:.5f} decades old."
...
>>> get_name_and_decades("Maria", 31)
My name is Maria and I'm 3.10000 decades old.
```

# 列表排序

Python中拥有内置函数实现排序，可以直接调用它们实现排序功能

Python 列表有一个内置的 `list.sort()` 方法可以直接修改列表。还有一个 `sorted()` 内置函数，它会从一个可迭代对象构建一个新的排序列表。

不管是 `list.sort` 方法还是 `sorted` 函数，都有两个可选的关键字参数。

> list.sort(cmp=None, key=None, reverse=False)
>
> 其中参数的含义是：
>
> * **cmp** -- 可选参数, 如果指定了该参数会使用该参数的方法进行排序。
>
> * **key** -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
>
> * **reverse** -- 排序规则，reverse = True 降序， reverse = False 升序（默认）。

> sorted(iterable, cmp=None, key=None, reverse=False)
>
> * **erable** -- 可迭代对象。
>
> * **cmp** -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
>
> * **key** -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
>
> * **reverse** -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。
>
> ```python
> # 默认情况下，sorted()已按升序对输入进行排序，而reverse关键字参数则按降序排序。
> >>> sorted(['cat', 'dog', 'cheetah', 'rhino', 'bear'], reverse=True)
> ['rhino', 'dog', 'cheetah', 'cat', 'bear]
> 
> >>> animals = [
> ...     {'type': 'penguin', 'name': 'Stephanie', 'age': 8},
> ...     {'type': 'elephant', 'name': 'Devon', 'age': 3},
> ...     {'type': 'puma', 'name': 'Moe', 'age': 5},
> ... ]
> >>> sorted(animals, key=lambda animal: animal['age'])
> [
>     {'type': 'elephant', 'name': 'Devon', 'age': 3},
>     {'type': 'puma', 'name': 'Moe', 'age': 5},
>     {'type': 'penguin', 'name': 'Stephanie, 'age': 8},
> ]
> # 通过传入一个返回每个元素年龄的lambda函数，可以轻松地按每个字典的单个值对字典列表进行排序。在这种情况下，字典现在按年龄按升序排序。
> ```
>
> 

> **sort ()与sorted()区别：**

sort() 是应用在 list 上的方法，sorted() 可以对所有可迭代的对象进行排序操作。

list 的 sort() 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted() 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。



# 集合论

> 集合的本质是许多唯一对象的聚集。因此，集合可以用于去重
>
> 集合中的元素必须是可散列的，`set` 类型本身是不可散列的，但是 `frozenset` 可以。因此可以创建一个包含不同 `frozenset` 的 `set`。
>
> 给定两个集合 `a` 和 `b`，`a | b` 返回的是它们的合集，`a & b` 得到的是交集，而 `a - b` 得到的是差集。
>
> 除空集之外，集合的字面量——`{1}`、`{1, 2}`，等等——看起来跟它的数学形式一模一样。如果是空集，那么必须写成 `set()` 的形式。
>
> 在 Python 3 里面，除了空集，集合的字符串表示形式总是以 `{...}` 的形式出现。
>
> 像 `{1, 2, 3}` 这种字面量句法相比于构造方法（`set([1, 2, 3])`）要更快且更易读。后者的速度要慢一些，因为 Python 必须先从 `set` 这个名字来查询构造方法，然后新建一个列表，最后再把这个列表传入到构造方法里。但是如果是像 `{1, 2, 3}` 这样的字面量，Python 会利用一个专门的叫作 `BUILD_SET` 的字节码来创建集合。

| 数学符号 | python运算符 | 方法 | 描述 |
| -------- | ------------ | ---- | ---- |
|          |              |      |      |
|          |              |      |      |
|          |              |      |      |

> `set`的实现以及导致的结果
>
> `set` 和 `frozenset` 的实现也依赖散列表，但在它们的散列表里存放的只有元素的引用（就像在字典里只存放键而没有相应的值）。在 `set` 加入到 Python 之前，我们都是把字典加上无意义的值当作集合来用的。
>
> 这些特点总结如下。
>
> - 集合里的元素必须是可散列的。
> - 集合很消耗内存。
> - 可以很高效地判断元素是否存在于某个集合。
> - 元素的次序取决于被添加到集合里的次序。
> - 往集合里添加元素，可能会改变集合里已有元素的次序。

```python
>>> import random
>>> all_words = "all the words in the world".split()
>>> def get_random_word():
...    return random.choice(all_words)
>>> def get_unique_words():
...     words = set()
...     for _ in range(1000):
...         words.add(get_random_word())
...     return words
>>> get_unique_words()
{'world', 'all', 'the', 'words'}
```







# 使用字符串常量访问公共字符串组

```python
# 可以使用is_upper()，它返回字符串中的所有字符是否都是大写字母：
>>> import string
>>> def is_upper(word):
...     for letter in word:
...         if letter not in string.ascii_uppercase:
...             return False
...     return True
...
>>> is_upper('Thanks Geir')
False
>>> is_upper('LOL')
True

# is_upper()迭代word中的字母，并检查字母是否为string.ascii_大写字母的一部分。如果你打印出string.ascii_大写，你会发现它只是一个字符串，该值设置为文本“ABCDEFGHIJKLMNOPQRSTUVWXYZ”。

所有字符串常量都只是经常引用的字符串值的字符串。其中包括以下内容：
string.ascii_letters
string.ascii_uppercase
string.ascii_lowercase
string.digits
string.hexdigits
string.octdigits
string.punctuation
string.printable
string.whitespace
```

# 使用Itertools生成排列和组合

```python
# itertools.permutations()构建所有排列的列表，这意味着它是输入值的每个可能分组的列表，其长度与count参数匹配。r关键字参数允许我们指定每个分组中有多少值：
>>> import itertools
>>> friends = ['Monique', 'Ashish', 'Devon', 'Bernie']
>>> list(itertools.permutations(friends, r=2))
[('Monique', 'Ashish'), ('Monique', 'Devon'), ('Monique', 'Bernie'),
('Ashish', 'Monique'), ('Ashish', 'Devon'), ('Ashish', 'Bernie'),
('Devon', 'Monique'), ('Devon', 'Ashish'), ('Devon', 'Bernie'),
('Bernie', 'Monique'), ('Bernie', 'Ashish'), ('Bernie', 'Devon')]

# itertools.combinations()生成组合。这些也是输入值的可能分组，但现在值的顺序无关紧要。
>>> list(itertools.combinations(friends, r=2))
[('Monique', 'Ashish'), ('Monique', 'Devon'), ('Monique', 'Bernie'),
('Ashish', 'Devon'), ('Ashish', 'Bernie'), ('Devon', 'Bernie')]
```

# 漂亮的打印出JSON

```python
>>> import json
>>> print(json.dumps(data))  # No indention
{"status": "OK", "count": 2, "results": [{"age": 27, "name": "Oz", "lactose_intolerant": true}, {"age": 29, "name": "Joe", "lactose_intolerant": false}]}
>>> print(json.dumps(data, indent=2))  # With indention
{
  "status": "OK",
  "count": 2,
  "results": [
    {
      "age": 27,
      "name": "Oz",
      "lactose_intolerant": true
    },
    {
      "age": 29,

      "name": "Joe",
      "lactose_intolerant": false
    }
  ]
}
```

# 上下文管理(with ** as ** )

```python
with allocate_resource() as resource:
    resource.use()

# 打开/关闭文件
with open('data.txt') as f:
    data = f.read()
```

# 合理使用列表

```python
from collections import deque
names = deque(['raymond', 'rachel', 'matthew', 'roger',
               'betty', 'melissa', 'judith', 'charlie'])
names.popleft()
               
Out[10]: 'raymond'
```

1. 列表对象（list）是一个查询效率高于更新操作的数据结构，删除和插入需要对剩下的元素做移动操作
2. deque 是一个双向队列的数据结构，删除元素和插入元素会很快

# 序列解包

> 元组拆包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接受这些元素的元组的空档数一致。除非我们用 `*` 来表示忽略多余的元素。
>
> os.path.split() 函数就会返回以路径和最后一个文件名组成的元组 (path, last_part)
>
> 在平行赋值中，`*` 前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置

```python
p = 'vttalk', 'female', 30, 'python@qq.com'
name, gender, age, email = p
name, gender, age, email
Out[13]: ('vttalk', 'female', 30, 'python@qq.com')
    
num_list = [100, 19, 20, 98]
first, *left_num_list, last = num_list
print(first, left_num_list, last)
Out[14]: 100 [19, 20] 98
    
string = 'xuexiao 4 fuzhou daxue'
tag,start_index,value = string.split(' ',2)
```

# 链式比较操作

```python
if 18 < age < 60:
    print("yong man")
```

# for/else语句

```python
# for else 是 Python 中特有的语法格式，else 中的代码在 for 循环遍历完所有元素之后执行
# 如果for循环正常结束，else中语句执行。如果是break的，则不执行。
for i in mylist:
    if i == theflag:
		break
    process(i)
else:
    raise ValueError("List argument missing terminal flag.")
```

```python
# 方式一
flag = False
for x in xx:
	if some condition:
		flag = True
		break
if flag:
	print 'no break'
```

```python
# 方式二
for x in xx:
	if some condition:
		break
else:
	print 'no break'
```

```python
# 判断质数/素数——我知道的最快的方法
# https://blog.csdn.net/songyunli1111/article/details/78690447
# Example
def is_prime(n = 20):
    is_p = False
    for ii in range(2 if n>=2 else 1, int(math.sqrt(n))+1):
        if n%ii == 0:
            break
    else:
        is_p = True
    return is_p
```

# assert用法

```python
>>> assert mul(2, 3) == 7, 'This statement is wrong!!!!!!'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError: This statement is wrong!!!!!!
```

# slots优化内存

> 使用__slots__使用了100M内存，比使用__dict__存储属性值节省了2倍。
> 其实使用collection模块的namedtuple也可以实现__slots__相同的功能。namedtuple其实就是继承自tuple，同时也因为__slots__的值被设置成了一个空tuple以避免创建__dict__
> collection 和普通创建类方式相比，也节省了不少的内存。所在在确定类的属性值固定的情况下，可以使用__slots__方式对内存进行优化。但是这项技术不应该被滥用于静态类或者其他类似场合，那不是python程序的精神所在。

```python
# 未使用__slots__
# -*- coding: utf-8 -*
from memory_profiler import profile
class Foobar(object):
    # __slots__ = ('x')
    def __init__(self, x):
        self.x = x
@profile
def main():
    f = [Foobar(42) for i in range(1000000)]
if __name__ == "__main__":
    main()

    
Line #    Mem usage    Increment   Line Contents
================================================
   137     45.7 MiB     45.7 MiB   @profile
   138                             def main():
   139    215.9 MiB      0.9 MiB       f = [Foobar(42) for i in range(1000000)]
```

```python
# 使用__slots__
# -*- coding: utf-8 -*
from memory_profiler import profile
class Foobar(object):
    __slots__ = ('x')
    def __init__(self, x):
        self.x = x
@profile
def main():
    f = [Foobar(42) for i in range(1000000)]

if __name__ == "__main__":
    main()

Line #    Mem usage    Increment   Line Contents
================================================
   132     45.7 MiB     45.7 MiB   @profile
   133                             def main():
   134     99.8 MiB      0.4 MiB       f = [Foobar(42) for i in range(1000000)]
```

```python
# 使用__slots__要注意，__slots__定义的属性仅对当前类起作用，对继承的子类是不起作用的
# 除非在子类中也定义__slots__，这样，子类允许定义的属性就是自身的__slots__加上父类的__slots__。
```

# 暂留
