<img src="http://upload-images.jianshu.io/upload_images/15675864-952291e89189c8a8.jpg">



记录python学习中遇到的一些心得：

[TOC]

***

# 装饰器(Dercrator)

```
1. 必须会 Python 装饰器的五个理由
	https://www.jianshu.com/p/d1afd5067dae
2. Python装饰器
	https://www.jianshu.com/p/18239508fe4c
用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景
用装饰器抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用
```

# 函数装饰函数

```python
def decorator(func):
    def inner(*args, **kwargs):
        print('before...........')
        res = func(*args, **kwargs)
        print('after............')
        return res
    return inner

@decorator
def run():
    print('run...............')
    return 0

if __name__ == "__main__":
    run()
    run.__name__
    # 此时decorator叫做装饰器
------------------------------------------
before...........
run...............
after............
inner
--------------------- 
```

## functools.wrap装饰器

**注意**: inner的返回值要与func的一致,并且inner与func参数相同

为了不改变被装饰函数或类的性质,添加functools.wrap装饰器

```python
from functools import wraps

def decorator(func):
    @wraps(func)
    def inner():
        print('before...........')
        res = func()
        print('after............')
        return res
    return inner

@decorator
def run():
    print('run...............')
    return 0

if __name__ == "__main__":
    run()
    print(run.__name__)
------------------------------------------
before...........
run...............
after............
run
--------------------- 
```

## 带参数的装饰器(3层)

```python
from functools import wraps
from datetime import datetime

def start():
    return datetime.now()
def end():
    return datetime.now()
def Filter(start_time, end_time):
    def decorator(func):
        @wraps(func)
        def inner(*args, **kwargs):
            s = start_time()
            res = func(*args,**kwargs)
            e = end_time()
            print("耗时{}".format((e-s).total_seconds()))
            return res
        return inner
    return decorator

@Filter(start, end)
def run():
    for i in range(2):
        for j in range(3):
            print(j)
    return 0
if __name__ == "__main__":
    run()
    
0
1
2
0
1
2
耗时0.003987    
```

## 带有不定参数的装饰器

```python
# 带有不定参数的装饰器
# 拓展的函数好多可是有参数，有的参数还是个数不定的那种
import time

def deco(func):
    def wrapper(*args, **kwargs):
        startTime = time.time()
        func(*args, **kwargs)
        endTime = time.time()
        msecs = (endTime - startTime) * 1000
        print("time is %d ms" % msecs)
    return wrapper

@deco
def func(a, b):
    print("hello,here is a func for add:")
    time.sleep(1)
    print("result is %d" % (a + b))

@deco
def func2(a, b, c):
    print("hello,here is a func for add:")
    time.sleep(1)
    print("result is %d" % (a + b + c))

if __name__ == '__main__':
    f = func
    func2(3, 4, 5)
    f(3, 4)
    
hello,here is a func for add:
result is 12
time is 1000 ms
hello,here is a func for add:
result is 7
time is 1000 ms
```

## 多个装饰器

```python
# 一个函数需要加入很多功能，一个装饰器怕是搞不定，装饰器能支持多个嘛
# 多个装饰器执行的顺序就是从最后一个装饰器开始，执行到第一个装饰器，再执行函数本身。
# 多个装饰器
import time
def deco01(func):
    def urapper(*args, **kwargs):
        print("this is decoe1")
        startTime = time.time()
        func(*args, **kwargs)
        endTime = time.time()
        msecs = (endTime - startTime) * 1000
        print("time is %d ms" % msecs)
        print("decoe1 end here")
    return urapper

def deco02(func):
    def wrapper(*args, **kwargs):
        print("this is decoe2")
        func(*args, **kwargs)
        print("decoe2 end here")
    return wrapper

@deco01
@deco02
def func(a, b):
    print("hello,here is a func for add:")
    time.sleep(1)
    print("result is %d" % (a + b))

if __name__ == '__main__':
    f = func
    f(3, 4)
    
this is decoe1
this is decoe2
hello,here is a func for add:
result is 7
decoe2 end here
time is 1003 ms
decoe1 end here
```



# 函数装饰类

```python
def wrapClass(cls):
    def inner(a):
        print('class name:', cls.__name__)
        return cls(a)
    return inner
@wrapClass
class Foo():
    def __init__(self, a):
        self.a = a

    def fun(self):
        print('self.a =', self.a)
m = Foo('xiemanR')
m.fun()

class name: Foo
self.a = xiemanR
```

1. **定义**

- 装饰器**不仅可以是函数，还可以是类** 
- 相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点
- 像`__call__`这样前后都带下划线的方法在Python中被称为内置(魔法)方法。重载这些魔法方法一般会改变对象的内部行为

2. **用法**

- 让类的构造函数`__init__()`接受一个函数
- **重载__call__()并 返回一个函数**
- 使用`@类`形式将装饰器附加到业务函数上

# 类装饰函数

```python
class ShowFunName():
    def __init__(self, func):
        self._func = func

    def __call__(self, a):
        print('function name:', self._func.__name__)
        return self._func(a)
@ShowFunName
def Bar(a):
    return a
print(Bar('xiemanR'))

function name: Bar
xiemanR
```



# 类装饰类

```python
class ShowClassName(object):
    def __init__(self, cls):
        self._cls = cls
    def __call__(self, a):
        print('class name:', self._cls.__name__)
        return self._cls(a)
@ShowClassName
class Foobar(object):
    def __init__(self, a):
        self.value = a
    def fun(self):
        print(self.value)
a = Foobar('xiemanR')
a.fun()

class name: Foobar
xiemanR
```

# functools模块

```python
使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表
functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的log函数也有和原函数test一样的元信息了
```

```python
def log(func):
    def wrapper():
        print("call test()")
        return func()
    return wrapper

@log
def test():
    print("this is what I want")

test()
print(test.__name__)

call test()
this is what I want
wrapper
```

```python
import functools

def log(func):
    @functools.wraps(func)
    def wrapper():
        print("call test()")
        return func()
    return wrapper

@log
def test():
    print("this is what I want")

test()
print(test.__name__)


call test()
this is what I want
test
```



# 内置装饰器

## 命令行神器Click

>1. [命令行神器 Click教程A篇](https://www.jianshu.com/p/d2b61a892c32)

```python
# -*- coding: utf-8 -*
import click
@click.command()
@click.option('--count', default=1, help='Number of greetings.')
@click.option('--name', prompt='Your name', help='The person to greet.')
def hello(count, name):
    """Simple program that greets NAME for a total of COUNT times."""
    for x in range(count):
        click.echo('Hello %s!' % name)
if __name__ == '__main__':
    hello()

Q:\pyCharmWS>python ./tempTest.py --count=3 --name=Ethan
Hello Ethan!
Hello Ethan!
Hello Ethan!
```

## @property和@classmethod

> 1. [python中常用的内置装饰器](https://blog.csdn.net/felix_yujing/article/details/79749944)

```python
# @property
# 使调用类中的方法像引用类中的字段属性一样。被修饰的特性方法，内部可以实现处理逻辑，但对外提供统一的调用方式。遵循了统一访问的原则。
# @classmethod
# 类方法的第一个参数是类，将类本身作为操作的方法。类方法被哪个类调用，就传入哪个类作为第一个参数进行操作。
# 注意，静态方法和类方法是为类操作准备的。虽然通过实例也能调用，但是不建议

# -*- coding: utf-8 -*
# coding: utf-8
class TestClass:
    name = "test"
    def __init__(self, name):
        self.name = name
    @property
    def sayHello(self):
        print("hello", self.name)
    @staticmethod
    def fun(self, x, y):
        return x + y
cls = TestClass("felix")
print(f"通过实例引用属性: {cls.name}")
print(f"像引用属性一样调用@property修饰的方法: {cls.sayHello}")
print(f"类名直接引用静态方法: {TestClass.fun(None, 2, 3)}")

通过实例引用属性: felix
hello felix
像引用属性一样调用@property修饰的方法: None
类名直接引用静态方法: 5
```

#  柯里化

>**柯里化（Currying）**
>将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。
>
>```python
>from functools import partial, wraps
>from inspect import getargspec
>@curried
>def add2(a,b,c):
>    return c * a + b
>add2(2)(5)(8)
>
>Out[45]: 21
>```
>
>>curry化最大的意义在于把多个参数的function等价转化成多个单参数function的级联，这样所有的函数就都统一了，方便做lambda演算。 在scala里，curry化对类型推演也有帮助，scala的类型推演是局部的，在同一个参数列表中后面的参数不能借助前面的参数类型进行推演，curry化以后，放在两个参数列表里，后面一个参数列表里的参数可以借助前面一个参数列表里的参数类型进行推演。这就是为什么 foldLeft这种函数的定义都是curry的形式。
>>
>>




