<img src="http://upload-images.jianshu.io/upload_images/15675864-952291e89189c8a8.jpg">



记录python学习中遇到的一些心得：

[TOC]

***

# 装饰器(Dercrator)

```
1. 必须会 Python 装饰器的五个理由
	https://www.jianshu.com/p/d1afd5067dae
2. Python装饰器
	https://www.jianshu.com/p/18239508fe4c
用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景
用装饰器抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用
```

> 函数装饰器在导入模块时立即执行，而被装饰的函数只有在明确调用时运行，这突出了导入时和运行时的区别。

## 闭包

> global关键字

如果在函数中赋值时想让解释器把 b 当成全局变量，要使用 global 声明：

```python
b = 6
def func(a):
    global b
    print(a)
    print(b)
    b = 9
```

> 闭包：只有涉及嵌套函数时才有闭包问题
>
> 闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。
>
> 在 `averager` 函数中，`series` 是**自由变量**（free variable）。这是一个技术术语，指未在本地作用域中绑定的变量

![img](.\res\4. 装饰器Dercrator\自由变量示例图.png)

**`averager` 的闭包延伸到那个函数的作用域之外，包含自由变量 `series` 的绑定**

> `nonlocal`声明

但是对数字、字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如 `count = count + 1`，其实会隐式创建局部变量 `count`。这样，`count` 就不是自由变量了，因此不会保存在闭包中。

为了解决这个问题，Python 3 引入了 `nonlocal` 声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为 `nonlocal` 声明的变量赋予新值，闭包中保存的绑定会更新。

```python
def make_averager():
    count = 0
    total = 0
    def averager(new_value):
        nonlocal count, total
        count += 1
        total += new_value
        return total / count
    return averager
```





# 函数装饰函数

```python
def decorator(func):
    def inner(*args, **kwargs):
        print('before...........')
        res = func(*args, **kwargs)
        print('after............')
        return res
    return inner

@decorator
def run():
    print('run...............')
    return 0

if __name__ == "__main__":
    run()
    run.__name__
    # 此时decorator叫做装饰器
------------------------------------------
before...........
run...............
after............
inner
--------------------- 
```

## functools.wrap装饰器

**注意**: inner的返回值要与func的一致,并且inner与func参数相同

为了不改变被装饰函数或类的性质,添加functools.wrap装饰器

```python
from functools import wraps

def decorator(func):
    @wraps(func)
    def inner():
        print('before...........')
        res = func()
        print('after............')
        return res
    return inner

@decorator
def run():
    print('run...............')
    return 0

if __name__ == "__main__":
    run()
    print(run.__name__)
------------------------------------------
before...........
run...............
after............
run
--------------------- 
```

## 带参数的装饰器(3层)

```python
from functools import wraps
from datetime import datetime

def start():
    return datetime.now()
def end():
    return datetime.now()
def Filter(start_time, end_time):
    def decorator(func):
        @wraps(func)
        def inner(*args, **kwargs):
            s = start_time()
            res = func(*args,**kwargs)
            e = end_time()
            print("耗时{}".format((e-s).total_seconds()))
            return res
        return inner
    return decorator

@Filter(start, end)
def run():
    for i in range(2):
        for j in range(3):
            print(j)
    return 0
if __name__ == "__main__":
    run()
    
0
1
2
0
1
2
耗时0.003987    
```

## 带有不定参数的装饰器

```python
# 带有不定参数的装饰器
# 拓展的函数好多可是有参数，有的参数还是个数不定的那种
import time

def deco(func):
    def wrapper(*args, **kwargs):
        startTime = time.time()
        func(*args, **kwargs)
        endTime = time.time()
        msecs = (endTime - startTime) * 1000
        print("time is %d ms" % msecs)
    return wrapper

@deco
def func(a, b):
    print("hello,here is a func for add:")
    time.sleep(1)
    print("result is %d" % (a + b))

@deco
def func2(a, b, c):
    print("hello,here is a func for add:")
    time.sleep(1)
    print("result is %d" % (a + b + c))

if __name__ == '__main__':
    f = func
    func2(3, 4, 5)
    f(3, 4)
    
hello,here is a func for add:
result is 12
time is 1000 ms
hello,here is a func for add:
result is 7
time is 1000 ms
```

## 多个装饰器

```python
# 一个函数需要加入很多功能，一个装饰器怕是搞不定，装饰器能支持多个嘛
# 多个装饰器执行的顺序就是从最后一个装饰器开始，执行到第一个装饰器，再执行函数本身。
# 多个装饰器
import time
def deco01(func):
    def urapper(*args, **kwargs):
        print("this is decoe1")
        startTime = time.time()
        func(*args, **kwargs)
        endTime = time.time()
        msecs = (endTime - startTime) * 1000
        print("time is %d ms" % msecs)
        print("decoe1 end here")
    return urapper

def deco02(func):
    def wrapper(*args, **kwargs):
        print("this is decoe2")
        func(*args, **kwargs)
        print("decoe2 end here")
    return wrapper

@deco01
@deco02
def func(a, b):
    print("hello,here is a func for add:")
    time.sleep(1)
    print("result is %d" % (a + b))

if __name__ == '__main__':
    f = func
    f(3, 4)
    
this is decoe1
this is decoe2
hello,here is a func for add:
result is 7
decoe2 end here
time is 1003 ms
decoe1 end here
```



# 函数装饰类

```python
def wrapClass(cls):
    def inner(a):
        print('class name:', cls.__name__)
        return cls(a)
    return inner
@wrapClass
class Foo():
    def __init__(self, a):
        self.a = a

    def fun(self):
        print('self.a =', self.a)
m = Foo('xiemanR')
m.fun()

class name: Foo
self.a = xiemanR
```

1. **定义**

- 装饰器**不仅可以是函数，还可以是类** 
- 相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点
- 像`__call__`这样前后都带下划线的方法在Python中被称为内置(魔法)方法。重载这些魔法方法一般会改变对象的内部行为

2. **用法**

- 让类的构造函数`__init__()`接受一个函数
- **重载__call__()并 返回一个函数**
- 使用`@类`形式将装饰器附加到业务函数上

# 类装饰函数

```python
class ShowFunName():
    def __init__(self, func):
        self._func = func

    def __call__(self, a):
        print('function name:', self._func.__name__)
        return self._func(a)
@ShowFunName
def Bar(a):
    return a
print(Bar('xiemanR'))

function name: Bar
xiemanR
```



# 类装饰类

```python
class ShowClassName(object):
    def __init__(self, cls):
        self._cls = cls
    def __call__(self, a):
        print('class name:', self._cls.__name__)
        return self._cls(a)
@ShowClassName
class Foobar(object):
    def __init__(self, a):
        self.value = a
    def fun(self):
        print(self.value)
a = Foobar('xiemanR')
a.fun()

class name: Foobar
xiemanR
```

# functools模块

```python
使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表
functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的log函数也有和原函数test一样的元信息了
```

```python
def log(func):
    def wrapper():
        print("call test()")
        return func()
    return wrapper

@log
def test():
    print("this is what I want")

test()
print(test.__name__)

call test()
this is what I want
wrapper
```

```python
import functools

def log(func):
    @functools.wraps(func)
    def wrapper():
        print("call test()")
        return func()
    return wrapper

@log
def test():
    print("this is what I want")

test()
print(test.__name__)


call test()
this is what I want
test
```



# 内置装饰器

## 命令行神器Click

>1. [命令行神器 Click教程A篇](https://www.jianshu.com/p/d2b61a892c32)

```python
# -*- coding: utf-8 -*
import click
@click.command()
@click.option('--count', default=1, help='Number of greetings.')
@click.option('--name', prompt='Your name', help='The person to greet.')
def hello(count, name):
    """Simple program that greets NAME for a total of COUNT times."""
    for x in range(count):
        click.echo('Hello %s!' % name)
if __name__ == '__main__':
    hello()

Q:\pyCharmWS>python ./tempTest.py --count=3 --name=Ethan
Hello Ethan!
Hello Ethan!
Hello Ethan!
```

## @property和@classmethod

> 1. [python中常用的内置装饰器](https://blog.csdn.net/felix_yujing/article/details/79749944)

```python
# @property
# 使调用类中的方法像引用类中的字段属性一样。被修饰的特性方法，内部可以实现处理逻辑，但对外提供统一的调用方式。遵循了统一访问的原则。
# @classmethod
# 类方法的第一个参数是类，将类本身作为操作的方法。类方法被哪个类调用，就传入哪个类作为第一个参数进行操作。
# 注意，静态方法和类方法是为类操作准备的。虽然通过实例也能调用，但是不建议

# -*- coding: utf-8 -*
# coding: utf-8
class TestClass:
    name = "test"
    def __init__(self, name):
        self.name = name
    @property
    def sayHello(self):
        print("hello", self.name)
    @staticmethod
    def fun(self, x, y):
        return x + y
cls = TestClass("felix")
print(f"通过实例引用属性: {cls.name}")
print(f"像引用属性一样调用@property修饰的方法: {cls.sayHello}")
print(f"类名直接引用静态方法: {TestClass.fun(None, 2, 3)}")

通过实例引用属性: felix
hello felix
像引用属性一样调用@property修饰的方法: None
类名直接引用静态方法: 5
```

## lru_cache做备忘

`functools.lru_cache` 是非常实用的装饰器，它实现了备忘（memoization）功能。这是一项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。LRU 三个字母是“Least Recently Used”的缩写，表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。

生成第 *n* 个斐波纳契数这种慢速递归函数适合使用 `lru_cache`

```python
import functools
from clockdeco import clock

@functools.lru_cache() # ➊
@clock  # ➋
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-2) + fibonacci(n-1)

if __name__=='__main__':
    print(fibonacci(6))
    
# 这样一来，执行时间减半了，而且 n 的每个值只调用一次函数
[0.00000119s] fibonacci(0) -> 0
[0.00000119s] fibonacci(1) -> 1
[0.00010800s] fibonacci(2) -> 1
[0.00000787s] fibonacci(3) -> 2
[0.00016093s] fibonacci(4) -> 3
[0.00001216s] fibonacci(5) -> 5
[0.00025296s] fibonacci(6) -> 8
```

除了优化递归算法之外，`lru_cache` 在从 Web 中获取信息的应用中也能发挥巨大作用。

特别要注意，`lru_cache` 可以使用两个可选的参数来配置。它的签名是：

```
functools.lru_cache(maxsize=128, typed=False)
```

`maxsize` 参数指定存储多少个调用的结果。缓存满了之后，旧的结果会被扔掉，腾出空间。为了得到最佳性能，`maxsize` 应该设为 2 的幂。`typed` 参数如果设为 `True`，把不同参数类型得到的结果分开保存，即把通常认为相等的浮点数和整数参数（如 `1` 和 `1.0`）区分开。顺便说一下，因为 `lru_cache` 使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，所以被 `lru_cache` 装饰的函数，它的所有参数都必须是**可散列的**。

## 单分派泛函数singledispatch

> [PEP 443 -- Single-dispatch generic functions](https://www.python.org/dev/peps/pep-0443/)

`functools.singledispatch` 是 Python 3.4 增加的，PyPI 中的 [`singledispatch`包](https://pypi.python.org/pypi/singledispatch)可以向后兼容 Python 2.6 到 Python 3.3。

假设我们在开发一个调试 Web 应用的工具，我们想生成 HTML，显示不同类型的 Python 对象。

我们可能会编写这样的函数：

```python
import html

def htmlize(obj):
    content = html.escape(repr(obj))
    return '<pre>{}</pre>'.format(content)
```

这个函数适用于任何 Python 类型，但是现在我们想做个扩展，让它使用特别的方式显示某些类型。

- `str`：把内部的换行符替换为 `' \n'`；不使用 ``，而是使用 ``。
- `int`：以十进制和十六进制显示数字。
- `list`：输出一个 HTML 列表，根据各个元素的类型进行格式化。

因为 Python 不支持重载方法或函数，所以我们不能使用不同的签名定义 `htmlize` 的变体，也无法使用不同的方式处理不同的数据类型。在 Python 中，一种常见的做法是把 `htmlize` 变成一个分派函数，使用一串 `if/elif/elif`，调用专门的函数，如 `htmlize_str`、`htmlize_int`，等等。这样不便于模块的用户扩展，还显得笨拙：时间一长，分派函数 `htmlize` 会变得很大，而且它与各个专门函数之间的耦合也很紧密。

Python 3.4 新增的 `functools.singledispatch` 装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用 `@singledispatch` 装饰的普通函数会变成**泛函数**（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数

> 如果根据多个参数选择专门的函数，那就是`多分派`了。

> `singledispatch` 创建一个自定义的 `htmlize.register` 装饰器，把多个函数绑在一起组成一个泛函数

```python
from functools import singledispatch
from collections import abc
import numbers
import html

@singledispatch  ➊
def htmlize(obj):
    content = html.escape(repr(obj))
    return '<pre>{}</pre>'.format(content)

@htmlize.register(str)  ➋
def _(text):            ➌
    content = html.escape(text).replace('\n', '<br>\n')
    return '<p>{0}</p>'.format(content)

@htmlize.register(numbers.Integral)  ➍
def _(n):
    return '<pre>{0} (0x{0:x})</pre>'.format(n)

@htmlize.register(tuple)  ➎
@htmlize.register(abc.MutableSequence)
def _(seq):
    inner = '</li>\n<li>'.join(htmlize(item) for item in seq)
    return '<ul>\n<li>' + inner + '</li>\n</ul>'
```

❶ `@singledispatch` 标记处理 `object` 类型的基函数。

❷ 各个专门函数使用 `@«base_function».register(«type»)` 装饰。

❸ 专门函数的名称无关紧要；`_` 是个不错的选择，简单明了。

❹ 为每个需要特殊处理的类型注册一个函数。`numbers.Integral` 是 `int` 的虚拟超类。

❺ 可以叠放多个 `register` 装饰器，让同一个函数支持不同类型。

只要可能，注册的专门函数应该处理抽象基类（如 `numbers.Integral` 和 `abc.MutableSequence`），不要处理具体实现（如 `int` 和 `list`）。这样，代码支持的兼容类型更广泛。例如，Python 扩展可以子类化 `numbers.Integral`，使用固定的位数实现 `int` 类型。

`singledispatch` 机制的一个显著特征是，你可以在系统的任何地方和任何模块中注册专门函数。如果后来在新的模块中定义了新的类型，可以轻松地添加一个新的专门函数来处理那个类型。此外，你还可以为不是自己编写的或者不能修改的类添加自定义函数。

> `@singledispatch` 不是为了把 Java 的那种方法重载带入 Python。在一个类中为同一个方法定义多个重载变体，比在一个函数中使用一长串 `if/elif/elif/elif` 块要更好。但是这两种方案都有缺陷，因为它们让代码单元（类或函数）承担的职责太多。`@singledispath` 的优点是支持模块化扩展：各个模块可以为它支持的各个类型注册一个专门函数。



#  柯里化

>柯里化（Currying）

将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。

>```python
># pip install simplecurry -i https://pypi.tuna.tsinghua.edu.cn/simple
>from simplecurry import curried
>
>@curried
>def add2(a,b,c):
>	return c * a + b
>add2(2)(5)(8)
>    
>>>> 21
>```
>
>>curry化最大的意义在于把多个参数的function等价转化成多个单参数function的级联，这样所有的函数就都统一了，方便做lambda演算。 在scala里，curry化对类型推演也有帮助，scala的类型推演是局部的，在同一个参数列表中后面的参数不能借助前面的参数类型进行推演，curry化以后，放在两个参数列表里，后面一个参数列表里的参数可以借助前面一个参数列表里的参数类型进行推演。这就是为什么 foldLeft这种函数的定义都是curry的形式。
>>
>>



# 案例

## 运行时间装饰器

>计算函数运行时间

```python
from functools import wraps

# 作为装饰器使用，返回函数执行需要花费的时间
def time_this_function(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'{func.__name__}, 耗时{round(end - start, 4)}s')
        return result
    return wrapper
```

