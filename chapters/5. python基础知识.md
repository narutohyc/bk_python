<img src="http://upload-images.jianshu.io/upload_images/15675864-952291e89189c8a8.jpg">



记录python学习中遇到的一些心得：

[TOC]

---

# python基础知识

## python解释器种类以及特点

```python
CPython：这个解释器是用C语言开发的，所以叫 CPython，在命名行下运行python，就是启动CPython解释器，CPython是使用最广的Python解释器；

IPython：IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强；

PyPy：PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，对Python代进行动态编译，所以可以显著提高Python代码的执行速度；

Jython：Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。

IronPython：IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。
```

## ascii、unicode、utf-8、gbk 区别

```python
ASCII码：使用一个字节编码，它的范围基本是只有英文字母、数字和一些特殊符号 ，只有256个字符;

Unicode：能够表示全世界所有的字节;

GBK：是只用来编码汉字的，GBK全称《汉字内码扩展规范》，使用双字节编码;

UTF-8：是一种针对Unicode的可变长度字符编码，又称万国码。
```

## 生成器和迭代器之间的区别

>1）在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()；
>
>2）在生成器中，我们使用关键字‘yield’来每次生成/返回一个对象；
>
>3）生成器中有多少‘yield’语句，你可以自定义；
>
>4）每次‘yield’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代；
>
>5）使用类可以实现你自己的迭代器，但无法实现生成器；
>
>6）生成器运行速度快，语法简洁，更简单；
>
>7）迭代器更能节约内存。

## Pipenv：项目环境与依赖管理工具

> 1. [Pipenv：新一代Python项目环境与依赖管理工具](https://zhuanlan.zhihu.com/p/37581807)
> 2. [pipenv使用指南](https://crazygit.wiseturtles.com/2018/01/08/pipenv-tour)

## 查看库中常用模块

```python
import math
dir(math)

['__doc__',
 '__loader__',
 '__name__',
 '__package__',
 '__spec__',
 'acos',
 'acosh',
 'asin',
 'asinh',
 'atan',
 'atan2',
 ...]
```

## linux后台执行py脚本

> nohup不能及时打印python print日志

**1、程序后台运行**

> nohup python test.py > tt.log>&1 &

**2、不能及时输出日志**

> nohup.out中显示不出来python程序中print的东西，这是因为python的输出有`缓冲`，导致nohup.out并不能够马上看到输出。

> python 有个-u参数，使得python不启用缓冲。
>
> nohup python -u test.py>tt.log>&1 &

> 还有一种方式(未尝试过)
>
> ```python
> import sys
> sys.stdout = Unbuffered(sys.stdout)
> ```
>
> 

## 代码调试技巧

> [Python 代码调试技巧](https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/index.html)
> 如果你使用的是Python 3.7，则无需导入任何内容，只需在代码中要放入调试器的位置调用breakpoint()：
> Some complicated code with bugs
>
> breakpoint()
> 调用breakpoint()会将你带入pdb，这是默认的Python调试器。在Python 3.6及更早版本中，你可以通过显式导入pdb来执行相同的操作：
>
> ```python
> import pdb; 
> pdb.set_trace()
> ```
>
> 像breakpoint()一样，pdb.set_trace()会将你带入pdb调试器。它不是那么简洁，而且需要记住的多一点。你可能想要尝试其他调试器，但pdb是标准库的一部分，因此它始终可用。无论你喜欢哪种调试器，在进行编码面试设置之前，都值得尝试使用它们来适应工作流程。

# 库和常用方法

## 变量存储工具方法

```python
# 什么是酸洗和去除？
# Pickle模块接受任何Python对象并将其转换为字符串表示形式，并使用dump函数将其转储到文件中，此过程称为pickling。从存储的字符串表示中检索原始Python对象的过程称为unpickling。

import dill
import pickle as pk
def dump_obj(obj, file_name):
    with open(file_name, 'wb') as f:
        dill.dump(obj, f)

def load_obj(file_name):
    with open(file_name, "rb") as f:
        try:
            return dill.load(f)
        except Exception:
            return pk.load(f)
```

## 数组按照某关键字比较

```python
pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda pair: pair[1])
print(pairs)

[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
```

## import路径问题

```python
import sys
sys.path.append("..")
# from utils import loadDate
```

## 判断是否有中文

```python
def is_chinese(uchar):
    if u'\u4e00' <= uchar <= u'\u9fff':
        return True
    else:
        return False
```

## 分割字符串并转换类型

```python
import numpy as np
line = '12,26,31,17,90,28,88,40,77'
npyArray = np.fromstring(line, dtype=int, sep=',')
print(npyArray)

array([12, 26, 31, 17, 90, 28, 88, 40, 77])
```

## 检查对象是否可调用

```python
def fn(a):
    print(a)
print(callable(fn))

True
```

## time库的使用

> [ `time`— Time access and conversions](https://docs.python.org/3.5/library/time.html#module-time)
>
> **time库是Python中处理时间的标准库**
>
> - 计算机时间的表达
> - 提供获取系统时间并格式化输出功能
> - 提供系统级精确计时功能，用于程序性能分析

> - 时间获取：time() ctime() gmtime()
> - 时间格式化：strftime() strptime()
> - 程序计时：sleep(), perf_counter()

## 时间获取

```python
# 获取当前时间戳，即计算机内部时间值，浮点数
# 
>>>time.time()
1568506809.169575

# 获取当前时间并以易读方式表示，返回字符串
# 等价于 time.asctime(time.localtime(time.time())), 将 gmtime()或localtime() 返回的 表示时间的 元组或struct_time 转换成一个字符串，格式：'Sun Jun 20 23:21:051993'。
>>>time.ctime()
'Sun Sep 15 08:20:16 2019'

# 获取当前时间，表示为计算机可处理的时间格式
# 等价于 time.localtime()
# 两者返回的时间是两个时区对相同时刻的时间表示。
# 其中，gmtime()表示的是0时区的标准时间，而localtime()表示的是本地时区的时间。
>>>time.gmtime()
time.struct_time(tm_year=2019, tm_mon=9, tm_mday=15, tm_hour=0, tm_min=21, tm_sec=40, tm_wday=6, tm_yday=258, tm_isdst=0)

# time.mktime(t)是localtime()的反函数
>>>time.mktime(time.localtime())
1568508316.0
```

> **struct_time元组的属性如下：**
>
> | 序号 | 属性     | 值                                   |
> | ---- | -------- | ------------------------------------ |
> | 0    | tm_year  | 2008                                 |
> | 1    | tm_mon   | 1 到 12                              |
> | 2    | tm_mday  | 1 到 31                              |
> | 3    | tm_hour  | 0 到 23                              |
> | 4    | tm_min   | 0 到 59                              |
> | 5    | tm_sec   | 0 到 61 (60或61 是闰秒)              |
> | 6    | tm_wday  | 0到6 (0是周一)                       |
> | 7    | tm_yday  | 1 到 366(儒略历)                     |
> | 8    | tm_isdst | -1, 0, 1, -1是决定是否为夏令时的旗帜 |

## 时间格式化

> 将时间以合理的方式展示出来
> - 格式化：类似字符串格式化，需要有展示模板
> - 展示模板由特定的格式化控制符组成
> - strftime()方法

```python
# strftime(tpl, ts)
# tpl是格式化模板字符串，用来定义输出效果
# ts是计算机内部时间类型变量
>>>t = time.gmtime()
>>>time.strftime("%Y-%m-%d %H:%M:%S",t)
'2019-09-15 00:24:23'

# strptime(str, tpl)
# str是字符串形式的时间值
# tpl是格式化模板字符串，用来定义输入效果
>>>timeStr = '2018-01-26 12:55:20'
>>>time.strptime(timeStr, "%Y-%m-%d %H:%M:%S")
time.struct_time(tm_year=2019, tm_mon=9, tm_mday=15, tm_hour=0, tm_min=25, tm_sec=50, tm_wday=6, tm_yday=258, tm_isdst=-1)
```

| 格式化字符串 | 日期/时间说明 | 值范围和实例                   |
| ------------ | ------------- | ------------------------------ |
| %Y           | 年份          | 0000~9999，例如：1900          |
| %m           | 月份          | 01~12，例如：10                |
| %B           | 月份名称      | January~December，例如：April  |
| %b           | 月份名称缩写  | Jan~Dec，例如：Apr             |
| %d           | 日期          | 01~31，例如：25                |
| %A           | 星期          | Monday~Sunday，例如：Wednesday |
| %a           | 星期缩写      | Mon~Sun，例如：Wed             |
| %H           | 小时（24h制） | 00~23，例如：12                |
| %h           | 小时（12h制） | 01~12，例如：7                 |
| %p           | 上/下午       | AM, PM，例如：PM               |
| %M           | 分钟          | 00~59，例如：26                |
| %S           | 秒            | 00~59，例如：26                |

## 程序计时

> - 程序计时指测量起止动作所经历时间的过程
> - 测量时间：perf_counter()
> - 产生时间：sleep()

```python
# 返回一个CPU级别的精确时间计数值，单位为秒
# 由于这个计数值起点不确定，连续调用差值才有意义
>>>start = time.perf_counter()
318.66599499718114
>>>end = time.perf_counter()
341.3905185375658
>>>end - start
22.724523540384666

# s拟休眠的时间，单位是秒，可以是浮点数
time.sleep(5)
```

## calendar库的使用

> 提供与日历相关功能，如：为给定的月份或年份，打印文本日历

```python
import calendar
c = calendar.month(2019, 9)
print(c)

   September 2019
Mo Tu We Th Fr Sa Su
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30

```

## datetime 模块

> - python 处理日期和时间的标准库
> - 常用 datetime 类，及 date 类 和 time 类
> - 可做计算之类的操作

```python
# 获取当天日期
import datetime
n = datetime.datetime.now()
t = datetime.datetime.today()
print(n)
print(t)
2019-09-15 15:16:22.032479
2019-09-15 15:16:22.032480
        
# 单独获取当前的年月日时分秒
import datetime
t = datetime.datetime.today()
print(type(t))
print(t.year)
print(t.month)
print(t.day)
print(t.hour)
print(t.minute)
print(t.second)
<class 'datetime.datetime'>
2019
9
15
15
16
49

# 计算 n 天之后的日期
import datetime
t = datetime.datetime.today()
result = t + datetime.timedelta(days=7)
print(t, result)
2019-09-15 15:17:34.975481 2019-09-22 15:17:34.975481
                
# 获取两个日期时间的时间差
import datetime
first = datetime.datetime(2017, 9, 2, 12, 00, 00)
second = datetime.datetime(2017, 9, 3, 12, 00, 00)
# print(first, type(first))
delta = second - first
print(delta, type(delta)) 
print(delta.total_seconds())
1 day, 0:00:00 <class 'datetime.timedelta'>
86400.0
```

## random库的使用

> random库是使用随机数的Python标准库
> - 伪随机数: 采用梅森旋转算法生成的(伪)随机序列中元素
> - random库主要用于生成随机数
> - 使用random库: import random

> - 基本随机数函数： seed(), random()
> - 扩展随机数函数： randint(), getrandbits(), uniform(),
> randrange(), choice(), shuffle()

### 基本随机数函数
![1568510165657](res/Python%20Base/1568510165657.png)

```python
# 初始化给定的随机数种子，默认为当前系统时间
>>>random.seed(10) #产生种子10对应的序列
# 生成一个[0.0, 1.0)之间的随机小数
>>>random.random()
0.5714025946899135

# 返回捕获当前生成器内部状态的对象.该对象可以用于函数setstate()取保存当前的状态.
>>> state = random.getstate()
>>> random.setstate(state)

# 以相同顺序打乱多个数组
# 等价于  np.random.get_state()    np.random.shuffle(a)   np.random.set_state(state)
a = np.arange(10)
b=['A','B','C','D','E','F','G','H','I','J']
state=random.getstate()
random.shuffle(a)
print(a)
random.setstate(state)
random.shuffle(b)
print(b)

[9 4 5 0 1 2 6 8 7 3]
['J', 'E', 'F', 'A', 'B', 'C', 'G', 'I', 'H', 'D']

```

### 扩展随机数函数

```python
# 生成一个[a, b]之间的整数
>>>random.randint(10, 100)
64

# 生成一个[m, n)之间以k为步长的随机整数
>>>random.randrange(10, 100, 10)
80
     
# 生成一个k比特长的随机整数
>>>random.getrandbits(16)
37885

# 生成一个[a, b]之间的随机小数
>>>random.uniform(10, 100)
13.096321648808136

# 从序列seq中随机选择一个元素
>>>random.choice([1,2,3,4,5,6,7,8,9])
8

# 将序列seq中元素随机排列，返回打乱后的序列
>>> s=[1,2,3,4,5,6,7,8,9];
>>> random.shuffle(s);
>>> print(s)
[3, 5, 8, 9, 6, 1, 2, 7, 4]
```

|         函数         |                   描述                    |
| :------------------: | :---------------------------------------: |
|    randint(a, b)     |         生成一个[a, b]之间的整数          |
| randrange(m, n[, k]) |   生成一个[m, n)之间以k为步长的随机整数   |
|    getrandbits(k)    |         生成一个k比特长的随机整数         |
|    uniform(a, b)     |       生成一个[a, b]之间的随机小数        |
|     choice(seq)      |        从序列seq中随机选择一个元素        |
|     shuffle(seq)     | 将序列seq中元素随机排列，返回打乱后的序列 |

## 命令行脚本传参

> [命令行运行Python脚本时传入参数的三种方式](https://blog.csdn.net/u012426298/article/details/80263507)
>
> 如果在运行python脚本时需要传入一些参数，例如`gpus`与`batch_size`，可以使用如下三种方式。
>
> ```cmd
> python script.py 0,1,2 10
> python script.py --gpus=0,1,2 --batch-size=10
> python script.py --gpus=0,1,2 --batch_size=10
> ```
>
> 这三种格式对应不同的参数解析方式，分别为`sys.argv`, `argparse`, `tf.app.run`, 前两者是python自带的功能，后者是`tensorflow`提供的便捷方式。

### sys.argv

> `sys`模块是很常用的模块， 它封装了与python解释器相关的数据，例如`sys.modules`里面有已经加载了的所有模块信息，`sys.path`里面是`PYTHONPATH`的内容，而`sys.argv`则封装了传入的参数数据。 
>
> 使用`sys.argv`接收上面第一个命令中包含的参数方式如下：
>
> ```python
> import sys
> gpus = sys.argv[1]
> #gpus = [int(gpus.split(','))]
> batch_size = sys.argv[2]
> print gpus
> print batch_size
> ```
>
> 

### argparse

> 需要注意的是，脚本运行命令`python script.py -gpus=0,1,2 --batch-size=10`中的`--batch-size`会被自动解析成`batch_size`. 
>
> parser.add_argument` 方法的`type`参数理论上可以是任何合法的类型， 但有些参数传入格式比较麻烦，例如list，所以一般使用`bool`, `int`, `str`, `float`这些基本类型就行了，更复杂的需求可以通过`str`传入，然后手动解析。`bool`类型的解析比较特殊，传入任何值都会被解析成`True`，传入空值时才为`False
>
> [使用argparse从命令行接收bool类型的参数](https://www.jianshu.com/p/7335651ca176)
>
> ```python
> import argparse
> def str2bool(v):
>     if v.lower() in ('yes', 'true', 't', 'y', '1'):
>         return True
>     elif v.lower() in ('no', 'false', 'f', 'n', '0'):
>         return False
>     else:
>         raise argparse.ArgumentTypeError('Unsupported value encountered.')
> 
> if __name__ == '__main__':
>     parser = argparse.ArgumentParser(description='manual to this script')
>     parser.add_argument('--zook_host', type=str, default='127.0.0.1:2181')
>     parser.add_argument('--num_of_task', type=int, default=10)
>     parser.add_argument('--is_del_aft', type=str2bool, default=False)
>     # parser.add_argument('--es_hosts', type=str, default='http://192.168.123.25:9200/')
>     args = parser.parse_args()
>     many_tasks_schedule_performance(zook_host=args.zook_host,
>                           num_of_task=args.num_of_task,
>                           is_del_aft=args.is_del_aft)
> ```
>
> 

### tf.app.run

> tensorflow也提供了一种方便的解析方式。 
>
> ```python
> import tensorflow as tf
> tf.app.flags.DEFINE_string('gpus', None, 'gpus to use')
> tf.app.flags.DEFINE_integer('batch_size', 5, 'batch size')
>  
> FLAGS = tf.app.flags.FLAGS
>  
> def main(_):
>     print FLAGS.gpus
>     print FLAGS.batch_size
>  
> if __name__=="__main__":
>     tf.app.run()
>     
> >>> python script.py --gpus=0,1,2 --batch_size=10
> ```
>
> 有几点需要注意：
>
> 1. `tensorflow`只提供以下几种方法： 
>    `tf.app.flags.DEFINE_string`， 
>    `tf.app.flags.DEFINE_integer`, 
>    `tf.app.flags.DEFINE_boolean`, 
>    `tf.app.flags.DEFINE_float` 四种方法，分别对应`str`, `int`,`bool`,`float`类型的参数。这里对`bool`的解析比较严格，传入1会被解析成`True`，其余任何值都会被解析成`False`。
>
> 2. 脚本中需要定义一个接收一个参数的`main`方法：`def main(_):`，这个传入的参数是脚本名，一般用不到， 所以用下划线接收。
>
> 3. 以`batch_size`参数为例，传入这个参数时使用的名称为`--batch_size`，也就是说，中划线不会像在`argparse` 中一样被解析成下划线。
>
> 4. `tf.app.run()`会寻找并执行入口脚本的`main`方法。也只有在执行了`tf.app.run()`之后才能从`FLAGS`中取出参数。 
>    从它的签名来看，它也是可以自己指定需要执行的方法的，不一定非得叫`main`：
>
>    ```python
>    run(
>        main=None,
>        argv=None
>    )
>    ```
>
> 5. `tf.app.flags`只是对`argpars`的简单封装。
>
> 6. 代码见https://github.com/tensorflow/tensorflow/blob/r1.2/tensorflow/python/platform/flags.py

## 随机打乱多个数组

>```python
>import numpy as np
>def shuffledata(*arrs):
>    # 調用案例 x,y = shuffledata(X,Y)
>    arrs = list(arrs)
>    for i, arr in enumerate(arrs):
>        assert len(arrs[0]) == len(arrs[i])
>        arrs[i] = np.array(arr)
>    p = np.random.permutation(len(arrs[0]))
>    return tuple(arr[p] for arr in arrs)
>```
>
>

## pandas读写csv

```python
#!/usr/bin/env Python
# -- coding: utf-8 --

"""
@version: v0.1
@author: narutohyc
@file: hyc_test.py
@Description: 
@time: 2020/5/28 20:08
"""

import pandas as pd


def csv_test():
    csv_name = 'my_csv.csv'
	# 初始化一个带表头的空表
    f1 = pd.DataFrame(None, columns=['name', 'price', 'marks'])
    f1.to_csv(csv_name, mode='w', encoding='utf-8', index=False)
	
    # 追加数据到已存在的表
    data = {"name": ['google', 'baidu', 'yahoo'], "marks": [100, 200, 300], "price": [1, 2, 3]}
    f1 = pd.DataFrame(data, columns=['name', 'price', 'marks'])
    f1.to_csv(csv_name, mode='a', encoding='utf-8', header=False, index=False)
	
    # 读取csv,index_col=False表示不存在索引列
    f2 = pd.read_csv(csv_name, encoding='utf-8', index_col=False)
    print()

if __name__ == '__main__':
    csv_test()
```









# pycharm基础设置

> 如果已经有setting.zip可以直接导入即可
>
> ./res/5. python基础知识/settings.zip

## pycharm激活

> [idea PyCharm 全家桶激活码 - lookdiv](http://lookdiv.com/)
>
> 秘钥: lookdiv.com

## git配置

> 配置git路径
>
> Setting->Version Control->git
>
> Path to Git executable: S:\Git\cmd\git.exe

## python模板设置

打开Setting->Editor->File and Code Templates->Files->Python Script

配置如下信息(修改作者名，其他无需修改)：

```python
#!/usr/bin/env Python
# -- coding: utf-8 --

"""
@version: v0.1
@author: narutohyc
@file: ${NAME}.py
@Description: 
@time: ${DATE} ${TIME}
"""


```

## 快捷键设置

| 操作                | 快捷键              | 补充说明                                                |
| ------------------- | ------------------- | ------------------------------------------------------- |
| Reformat Code       | Ctrl+Alt+F          | 格式化代码                                              |
| Close               | Ctrl+R              | 关闭当前py文件窗口                                      |
| Split Vertically    | Ctrl+Shift+向右箭头 | 垂直切分窗口                                            |
| Split Horizontally  | Ctrl+Shift+向左箭头 | 水平切分窗口                                            |
| Git Pull            | Ctrl+Shift+L        | git pull                                                |
| Git commit File     | Ctrl+K              | git commit                                              |
| Git Commit and push | Ctrl+Shift+K        | git push                                                |
| Change font size    |                     | ctrl+N->Actions->Change font size with Ctrl+Mouse Wheel |
| Show in Explorer    | Crtl+Shift+S        |                                                         |
|                     |                     |                                                         |













